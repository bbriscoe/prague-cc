<?xml version="1.0" encoding="US-ASCII"?>
<!-- This template is for creating an Internet Draft using xml2rfc,
    which is available here: http://xml.resource.org. -->
<!DOCTYPE rfc SYSTEM "rfc2629.dtd">
<?xml-stylesheet type='text/xsl' href='rfc2629.xslt' ?>
<!-- used by XSLT processors -->
<!-- For a complete list and description of processing instructions (PIs), 
    please see http://xml.resource.org/authoring/README.html. -->
<!-- Below are generally applicable Processing Instructions (PIs) that most I-Ds might want to use.
    (Here they are set differently than their defaults in xml2rfc v1.32) -->
<?rfc strict="yes" ?>
<!-- give errors regarding ID-nits and DTD validation -->
<!-- control the table of contents (ToC) -->
<?rfc toc="yes"?>
<!-- generate a ToC -->
<?rfc tocdepth="4"?>
<!-- the number of levels of subsections in ToC. default: 3 -->
<!-- control references -->
<?rfc symrefs="yes"?>
<!-- use symbolic references tags, i.e, [RFC2119] instead of [1] -->
<?rfc sortrefs="yes" ?>
<!-- sort the reference entries alphabetically -->
<!-- control vertical white space 
    (using these PIs as follows is recommended by the RFC Editor) -->
<?rfc compact="yes" ?>
<!-- do not start each main section on a new page -->
<?rfc subcompact="no" ?>
<!-- keep one blank line between list items -->
<!-- end of list of popular I-D processing instructions -->
<rfc category="exp" docName="draft-briscoe-iccrg-prague-congestion-control-00"
     ipr="trust200902" updates="">
  <!-- category values: std, bcp, info, exp, and historic
    ipr values: trust200902, noModificationTrust200902, noDerivativesTrust200902,
       or pre5378Trust200902
    you can add the attributes updates="NNNN" and obsoletes="NNNN" 
    they will automatically be output with "(if approved)" -->

  <!-- ***** FRONT MATTER ***** -->

  <front>
    <!-- The abbreviated title is used in the page header - it is only necessary if the 
       full title is longer than 39 characters -->

    <title abbrev="Prague Congestion Control">Prague Congestion
    Control</title>

    <author fullname="Koen De Schepper" initials="K." surname="De Schepper">
      <organization>Nokia Bell Labs</organization>

      <address>
        <postal>
          <street/>

          <city>Antwerp</city>

          <country>Belgium</country>
        </postal>

        <email>koen.de_schepper@nokia.com</email>

        <uri>https://www.bell-labs.com/usr/koen.de_schepper</uri>
      </address>
    </author>

    <author fullname="Olivier Tilmans" initials="O." surname="Tilmans">
      <organization>Nokia Bell Labs</organization>

      <address>
        <postal>
          <street/>

          <city>Antwerp</city>

          <country>Belgium</country>
        </postal>

        <email>olivier.tilmans@nokia-bell-labs.com</email>
      </address>
    </author>

    <author fullname="Bob Briscoe" initials="B." role="editor"
            surname="Briscoe">
      <organization>Independent</organization>

      <address>
        <postal>
          <street/>

          <country>UK</country>
        </postal>

        <email>ietf@bobbriscoe.net</email>

        <uri>http://bobbriscoe.net/</uri>
      </address>
    </author>

    <author fullname="Asad Sajjad Ahmed" initials="A.S." surname="Ahmed">
      <organization>Independent</organization>

      <address>
        <postal>
          <street/>

          <country>Norway</country>
        </postal>

        <email>me@asadsa.com</email>
      </address>
    </author>

    <date month="" year="2020"/>

    <area>IRTF</area>

    <workgroup>Internet Congestion Control Research Group (ICCRG)</workgroup>

    <keyword>Internet-Draft</keyword>

    <keyword>I-D</keyword>

    <abstract>
      <t>{ToDo, something like:} This Informational/experimental RFC describes
      the Prague congestion control scheme, derived from DCTCP and adapted for
      Internet traffic by fulfilling the L4S Prague requirements. It reuses
      the DCTCP mechanisms to achieve high-burst tolerance, low latency, and
      high throughput on L4S supporting network nodes. Prague TCP is intended
      to be deployed on the Internet where it is compatible with TCP-Reno on
      drop based bottlenecks (AQM, policers or taildrop) and with L4S network
      support also on ECN based bottlenecks. Prague TCP can only achieve its
      low latency and high throughput when its packets are marked with a
      shallow ECN threshold and can only achieve its throughput fairness when
      a Coupled or FQ AQM mechanism is in place. For Classic ECN bottlenecks
      (RFC...) that are unaware of L4S, operators might want to apply
      additional measures to limit or avoid the higher throughput use of L4S
      Prague traffic. This memo presents the current state of the Linux Prague
      TCP implementation and some possible opprtunities for further
      performance improvements.</t>
    </abstract>
  </front>

  <middle>
    <section anchor="pracc_intro" title="Introduction">
      <t>{ToDo: Copy largely from netdev Prague paper (not too elaborate)}</t>

      <section anchor="pracc_motivation"
               title="Motivation: Low Delay /and/ High Bandwidth">
        <t>{ToDo: Copy largely from netdev Prague paper.}</t>

        <t>Not just for today's scale - mention scaling as well as low delay,
        high bandwidth.</t>
      </section>

      <section anchor="pracc_roadmap" title="Document Purpose and Roadmap">
        <t>{ToDo: Explain that there is not 'One True Prague CC'. L4S is
        intended to enable development of any scalable CC that meets the
        Prague requirements. This doc is only meant to describe a reference
        implementation. It doesn't satisfy all the requirements, and the IETF
        might decide that certain requirements need to be relaxed as an
        outcome of the process of trying to satisfy them all.}</t>
      </section>

      <section anchor="pracc_Terminology" title="Terminology">
        <t>The key words "MUST", "MUST NOT", "REQUIRED", "SHALL", "SHALL NOT",
        "SHOULD", "SHOULD NOT", "RECOMMENDED", "MAY", and "OPTIONAL" in this
        document are to be interpreted as described in <xref
        target="RFC2119"/> when, and only when, they appear in all capitals,
        as shown here.</t>

        <t>Definitions of terms used {ToDo: Currently inherited from dualq
        draft - may need to prune}:<list style="hanging">
            <t hangText="Classic Congestion Control:">A congestion control
            behaviour that can co-exist with standard TCP Reno <xref
            target="RFC5681"/> without causing significantly negative impact
            on its flow rate <xref target="RFC5033"/>. With Classic congestion
            controls, as flow rate scales, the number of round trips between
            congestion signals (losses or ECN marks) rises with the flow rate.
            So it takes longer and longer to recover after each congestion
            event. Therefore control of queuing and utilization becomes very
            slack, and the slightest disturbance prevents a high rate from
            being attained <xref target="RFC3649"/>.</t>

            <t hangText="Scalable Congestion Control:">A congestion control
            where the average time from one congestion signal to the next (the
            recovery time) remains invariant as the flow rate scales, all
            other factors being equal. This maintains the same degree of
            control over queueing and utilization whatever the flow rate, as
            well as ensuring that high throughput is robust to disturbances.
            For instance, DCTCP averages 2 congestion signals per round-trip
            whatever the flow rate. For the public Internet a Scalable
            transport has to comply with the requirements in Section 4
            of&nbsp;<xref target="I-D.ietf-tsvwg-ecn-l4s-id"/> (aka. the
            'Prague L4S requirements').</t>

            <t hangText="Reno-friendly:">The subset of Classic traffic that
            excludes unresponsive traffic and excludes experimental congestion
            controls intended to coexist with Reno but without always being
            strictly friendly to it (as allowed by <xref target="RFC5033"/>).
            Reno-friendly is used in place of 'TCP-friendly', given that the
            TCP protocol is used with many different congestion control
            behaviours.</t>

            <t hangText="Classic ECN:">The original Explicit Congestion
            Notification (ECN) protocol <xref target="RFC3168"/>, which
            requires ECN signals to be treated the same as drops, both when
            generated in the network and when responded to by the
            sender.<vspace blankLines="1"/>The names used for the four
            codepoints of the 2-bit IP-ECN field are as defined in <xref
            target="RFC3168"/>: Not ECT, ECT(0), ECT(1) and CE, where ECT
            stands for ECN-Capable Transport and CE stands for Congestion
            Experienced.</t>

            <t hangText="CC:">Congestion Control</t>

            <t hangText="ACK:">an ACKnowledgement, or to ACKnowledge</t>

            <t hangText="EWMA:">Exponentially Weighted Moving Average</t>

            <t hangText="RTT:">Round Trip Time</t>
          </list></t>

        <t>Definitions of Parameters and Variables:<list style="hanging">
            <t hangText="MTU_BITS:">Maximum transmission unit [b]</t>

            <t hangText="cwnd:">Congestion window [B]</t>

            <t hangText="ssthresh:">Slow start threshold [B]</t>

            <t hangText="inflight:">The amount of data that the sender has
            sent but not yet received ACKs for [B]</t>

            <t hangText="p:">Steady-state probability of drop or marking
            []</t>

            <t hangText="alpha:">EWMA of the ECN marking fraction []</t>

            <t hangText="acked_sacked:">the amount of new data acknowledged by
            an ACK [B]</t>

            <t hangText="ece_delta:">the amount of newly acknowledged data
            that was ECN-marked [B]</t>

            <t hangText="ai_per_rtt:">additive increase to apply per RTT
            [B]</t>

            <t hangText="srtt:">Smoothed round trip time [s]</t>

            <t hangText="MAX_BURST_DELAY:">Maximum allowed bottleneck queuing
            delay due to segmentation offload bursts [s] (default 0.25 ms for
            the public Internet)</t>
          </list></t>
      </section>
    </section>

    <section anchor="pracc_l4s" title="Bigger Picture - L4S Overview">
      <t/>

      <section title="Low Queuing Delay and High Utilization">
        <t>{ToDo: Copy largely from netdev Prague paper}</t>
      </section>

      <section title="Immediate Explicit Congestion Notification">
        <t>{ToDo: Copy largely from netdev Prague paper}</t>
      </section>

      <section title="Scaling with Flow Rate">
        <t>{ToDo: Copy largely from netdev Prague paper}</t>
      </section>

      <section title="Coexistence with Existing Traffic">
        <t>{ToDo: Copy largely from netdev Prague paper}</t>
      </section>

      <section title="The Prague L4S Requirements">
        <t>{ToDo: Copy largely from netdev Prague paper}</t>
      </section>
    </section>

    <section title="DCTCP: Brief Recap">
      <t>{ToDo} Is this needed? Can't we just refer to the DCTCP RFC if
      interested? We will anyway axplain all aspects? or not?</t>
    </section>

    <section anchor="pracc_prague_cc" title="Prague Congestion Control">
      <t>{ToDo: In each subsection, change "This section addresses Req 4.1.
      [xref-ecn-l4s-id]." to a parenthesis after a (probably pre-existing)
      sentence that describes the requirement.}</t>

      <section anchor="pracc_pkt_id" title="Packet Identification">
        <t>On the public Internet, a sender using the Prague CC MUST set the
        ECT(1) codepoint on all the packets it sends, in order to identify
        itself as an L4S-capable congestion control (Req 4.1 <xref
        target="I-D.ietf-tsvwg-ecn-l4s-id"/>).</t>

        <t>This applies whatever the transport protocol, whether TCP, QUIC,
        RTP, etc. In the case of TCP, unlike an RFC 3168 TCP ECN transport, a
        sender can set all packets as ECN-capable, including TCP control
        packets and retransmissions <xref target="RFC8311"/>, <xref
        target="I-D.ietf-tcpm-generalized-ecn"/>.</t>

        <t>The Prague CC SHOULD optionally be configurable to use the ECT(0)
        codepoint in private networks, such as data centres, which might be
        necessary for backward compatibility with DCTCP deployments where
        ECT(1) might already have another usage.</t>

        <t>Implementation note:<list style="hanging">
            <t hangText="TCP Prague in Linux  kernel:">The kernel was updated
            to allow the ECT(1) flag to be set from within a CC module. The
            Prague CC then has full control over the ECN code point it uses at
            any one time. In this way it enforces the use of ECT(1) (or
            optionally ECT(0)) and non-ECT when required.</t>
          </list></t>
      </section>

      <section title="Detecting and Measuring Congestion">
        <t/>

        <section title="Accurate ECN Feedback">
          <t>When feedback of ECN markings was added to TCP <xref
          target="RFC3168"/>, it was decided not to report any more than one
          mark per RTT. L4S-capable congestion controls need to know the
          extent, not just the existence of congestion (Req 4.2. <xref
          target="I-D.ietf-tsvwg-ecn-l4s-id"/>). Recently defined transports
          (DCCP, QUIC, etc) typically already satisfy this requirement. So
          they are dealt with separately below, while TCP and derivatives such
          as SCTP <xref target="RFC4960"/> are covered first.</t>

          <section title="Accurate ECN Feedback with TCP &amp; Derivatives">
            <t>The TCP wire protocol is being updated to allow more accurate
            feedback (AccECN <xref target="I-D.ietf-tcpm-accurate-ecn"/>).
            Therefore, in the case where a sender uses the Prague CC over TCP,
            whether as client or server:<list style="symbols">
                <t>it MUST itself support AccECN;</t>

                <t>to support AccECN it also has to check that its peer
                supports AccECN during the handshake.</t>
              </list>If the peer does not support accurate ECN feedback, the
            sender MUST fall back to a Reno-friendly CC behaviour for the rest
            of the connection. The non-Prague TCP sender MUST then no longer
            set ECT(1) on the packets it sends. Note that the peer only needs
            to support AccECN; there is no need (and no way) to find out
            whether the peer is using an L4S-capable congestion control.</t>

            <t>Note that a sending TCP client that uses the Prague CC can set
            ECT(1) on the SYN prior to checking whether the other peer
            supports AccECN (as long as it follows the procedure in <xref
            target="I-D.ietf-tcpm-generalized-ecn"/> if it discovers the peer
            does not support AccECN).</t>

            <t>Implementation note:<list style="hanging">
                <t hangText="TCP Prague in Linux  kernel:">The kernel had been
                updated to support AccECN Independent of the CC module in use.
                So the kernel tries to negotiate AccECN exchange whichever
                congestion control module is selected. An additional check is
                provided to verify that the kernel actually does support
                AccECN, based on which the Prague CC module will decide to
                proceed using scalable CC or fall back to a Classic CC (Reno
                in the current implementation).<vspace blankLines="1"/>A
                system wide option is available to disable AccECN negotiation,
                but the Prague CC module will always override this setting, as
                it depends on AccECN. Then, solely in this case, AccECN will
                only be active for TCP flows using the Prague CC. </t>
              </list></t>
          </section>

          <section title="Accurate ECN Feedback with Other Modern Transports">
            <t>Transport protocols specified recently, .e.g. DCCP <xref
            target="RFC4340"/>, QUIC <xref target="I-D.ietf-quic-transport"/>,
            are unambiguously suitable for Prague CCs, because they were
            designed from the start with accurate ECN feedback.</t>

            <t>In the case of RTP/RTCP, ECN feedback was added in <xref
            target="RFC6679"/>, which is sufficient for the Prague CC.
            However, it is preferable to use the most recent improvements to
            ECN feedback in <xref
            target="I-D.ietf-avtcore-cc-feedback-message"/>.</t>
          </section>
        </section>

        <section anchor="pracc_moving_avg"
                 title="Moving Average of ECN Feedback">
          <t>The Prague CC currently maintains a moving average of ECN
          feedback in a similar way to DCTCP. This section is provided mainly
          because performance has proved to be sensitive to implementation
          precision in this area. So first, some background is necessary.</t>

          <t>The Prague CC triggers update of its moving average once per RTT
          by recording the packet it sent after the previous update, then
          watching for the ACK of that packet to return. To maintain its
          moving average, it measures the fraction, frac, of ACKed bytes that
          carried ECN feedback over the previous round trip. It then updates
          an exponentially weighted moving average (EWMA) of this fraction,
          called alpha, using the following algorithm:<list style="empty">
              <t>alpha += g * (frac - alpha);</t>
            </list>where g is the gain of the EWMA (default 1/16).</t>

          <t>Implementation notes:<list style="hanging">
              <t hangText="Rounding problems in DCTCP:">Alpha is a fraction
              between 0 and 1, and it needs to be represented with high
              resolution because the larger the bandwidth-delay product (BDP)
              of a flow, the smaller the value that alpha converges to (in
              steady state alpha = 2/cwnd). In principle, Linux DCTCP
              maintains the moving average 'alpha' using the same formula as
              Prague CC uses (as above). Linux represents alpha with a 10-bit
              integer (with resolution 1/1024). However, up to kernel release
              3.19, Linux used integer arithmetic that could not reduce alpha
              below 15/1024. Then it was patched so that any value below
              16/1024 was rounded down to zero <xref
              target="patch-alpha-zero"/>. For a flow with a higher BDP than
              128 segments, this means that, alpha flip-flops. Once it has
              flopped down to zero DCTCP becomes unresponsive until it has
              built sufficient queue to flip up to 16/1024. For larger BDPs,
              this causes DCTCP to induce larger sawteeth, which loses the
              low-queuing-delay and high-utilization intent of the
              algorithm.</t>

              <t hangText="Upscaled alpha in Prague CC:">To resolve the above
              problem the implementation of TCP Prague in Linux maintains
              upscaled_alpha = alpha/g instead of alpha:<list style="empty">
                  <t>upscaled_alpha += frac - g * upscaled_alpha;</t>
                </list>This technique is the same as Linux uses for the
              retransmission timer variables, srtt and mdev. Prague CC also
              uses 20 bits for alpha,</t>
            </list></t>

          <t>Currently the above per-RTT update to the moving average, which
          was inherited from DCTCP, is the default in the Prague CC. However,
          another approach is being investigated because these per-RTT updates
          introduce 1--2 rounds of delay into the congestion response on top
          of the inherent round of feedback delay (see <xref
          target="pracc_faster_response"/> in the section on variants and
          future work).</t>
        </section>

        <section title="Scaling Loss Detection with Flow Rate">
          <t>After an ACK leaves a gap in the sequence space, a Prague CC is
          meant to deem that a loss has occurred using 'time-based units' (Req
          4.3. <xref target="I-D.ietf-tsvwg-ecn-l4s-id"/>). This is in
          contrast to the traditional approach that counts a hard-coded number
          of duplicate ACKs, e.g. the 3 Dup-ACKs specified in <xref
          target="RFC5681"/>. Counting packets rather than time unnecessarily
          tightens the time within which parallelized links have to keep
          packets in sequence as flow rate scales over the years.</t>

          <t>To satsify this requirement, a Prague CC SHOULD wait until a
          certain fraction of the RTT has elapsed before it deems that the gap
          is due to packet loss. The reference implementation of TCP Prague in
          Linux uses RACK <xref target="I-D.ietf-tcpm-rack"/> to address this
          requirement. An approach similar to TCP RACK is also used in
          QUIC.</t>

          <t>At the start of a connection, RACK counts 3 DupACKs to detect
          loss because the initial smoothed RTT estimate can be inaccurate.
          This would depend indirectly on time as long as the initial window
          (IW) is paced over a round trip (see <xref
          target="pracc_flow_start"/>). For instance, if the initial window of
          10 segments was paced evenly across the initial RTT then, in the
          next round, an implementation that deems there has been a loss after
          (say) 1/4 of an RTT can count 1/4 of 10 = 3 DupACKs (rounded up).
          Subsequently, as the window grows, RACK shifts to using a fraction
          of the RTT for loss detection.</t>
        </section>
      </section>

      <section title="Congestion Response Algorithm">
        <t>In congestion avoidance phase, a Prague CC uses a similar additive
        increase multiplicative decrease (AIMD) algorithm to DCTCP, but with
        the following differences:</t>

        <section title="Fall-Back on Loss">
          <t>A Prague CC has to fall back to Reno-friendly behaviour on
          detection of a loss (Req 4.3. <xref
          target="I-D.ietf-tsvwg-ecn-l4s-id"/>). DCTCP falls back to Reno for
          the round trip after a loss, and the Linux reference implementation
          of TCP Prague inherits this behaviour.</t>

          <t>If a Prague CC has already reduced cwnd due to ECN feedback less
          than a round trip before it detects a loss, it MAY reduce cwnd by a
          smaller amount due to the loss, as long as the reductions due to ECN
          and the loss are Reno-friendly when taken together.</t>

          <t>See <xref target="pracc_delay-based"/> for discussion of future
          work on congestion control using a combination of delay, ECN and
          loss.</t>

          <t>Implementation note:<list style="hanging">
              <t hangText="DCTCP bug prior to v5.1:">A Prague CC cannot rely
              on the fall-back-on-loss behaviour of the DCTCP code in the
              Linux kernel prior to v5.1, due to a previous bug in the fast
              retransmit code (but not in the retransmission timeout code)
              <xref target="patch-loss-react"/>.</t>
            </list></t>
        </section>

        <section title="Multiplicative Decrease on ECN Feedback">
          <t>The Prague CC currently responds to ECN feedback in a similar way
          to DCTCP. This section is provided mainly because performance has
          proved to be sensitive to implementation details in this area. So
          the following recap of the congestion response is needed first.</t>

          <t>As explained in <xref target="pracc_moving_avg"/>, the Prague CC
          (like DCTCP) clocks its moving average of ECN-marking, alpha, once
          per round trip throughout a connection. Nonetheless, it only
          triggers a multiplicative decrease to its congestion window when it
          actually receives an ACK carrying ECN feedback. Then it suppresses
          any further decreases for one round trip, even if it receives
          further ECN feedback. This is termed Congestion Window Reduced or
          CWR state.</t>

          <t>The Prague CC (like DCTCP) ensures that the average recovery time
          remains invariant as flow rate scales (Req 4.3 of <xref
          target="I-D.ietf-tsvwg-ecn-l4s-id"/>) by making the multiplicative
          decrease depend on the prevailing value of alpha as follows:<list
              style="empty">
              <t>ssthresh = (1 - alpha/2) * cwnd;</t>
            </list></t>

          <t>Implementation notes:<list style="hanging">
              <t hangText="Upscaled alpha:">With reference to the earlier
              discussion of integer arithmetic precision (<xref
              target="pracc_moving_avg"/>), alpha = g * upscaled_alpha.</t>

              <t hangText="Carry of fractional cwnd remainder:">Typically the
              absolute reduction in cwnd is only a small number of segments.
              So, if the Prague CC implementation counts the window in integer
              segments (as in the Linux reference code), delay can be made
              significantly less jumpy by tracking a fractional value
              alongside the integer window and carrying over any fractional
              remainder to the next reduction. Also, integer rounding bias
              ought to be removed from the multiplicative decrease
              calculation.</t>
            </list></t>

          <t>In dynamic scenarios, as flows find a new operating point, alpha
          will have often tailed away to near-nothing before the onset of
          congestion. Then DCTCP's tiny reduction followed by no further
          response for a round is precisely the wrong way for a CC to respond.
          A solution to this problem is being evaluated as part of the work
          already mentioned to improve Prague's responsiveness (see <xref
          target="pracc_faster_response"/> in the section on variants and
          future work).</t>
        </section>

        <section title="Additive Increase and ECN Feedback">
          <t>Unlike DCTCP, the Prague CC does not suppress additive increase
          for one round trip after a congestion window reduction (while in CWR
          state). Instead, a Prague CC applies additive increase irrespective
          of its CWR state, but only for bytes that have been ACK'd without
          ECN feedback. Specifically, on each ACK,<figure>
              <artwork><![CDATA[    cwnd += (acked_sacked - ece_delta) * ai_per_rtt / cwnd;
]]></artwork>
            </figure>where:<list style="empty">
              <t>acked_sacked is the number of new bytes acknowledged by the
              ACK;</t>

              <t>ece_delta is the number of newly acknowledge ECN-marked
              bytes;</t>

              <t>ai_per_rtt is a scaling factor that is typically 1 SMSS
              except for small RTTs (see <xref
              target="pracc_rtt_independence"/>)</t>
            </list></t>

          <t>Superficially, the traditional suppression of additive increase
          for the round after a decrease seems to make sense. However, DCTCP
          and Prague are designed to induce an average of 2 congestion marks
          per RTT in steady state, which leaves very little space for any
          increase between the end of one round of CWR and the next mark. In
          tests, when a test version of Prague CC is configured to completely
          suppress additive increase during CWR (like Reno and DCTCP), it
          sawteeth become more irregular, which is its way of making some
          decreases large enough to open up enough space for an increase. This
          irregularity tends to reduce link utilization. Therefore, the
          reference Prague CC continues additive increase irrespective of CWR
          state.</t>

          <t>Nonetheless, rather than continue additive increase regardless of
          congestion, it is safer to only increase on those ACKs that do not
          feed back congestion. This approach reduces additive increase as the
          marking probability increases, which tends to keep the marking level
          unsaturated (below 100%) (see Section 3.1 of <xref
          target="Tensions17"/>). Under stable conditions, Prague's congestion
          window then becomes proportional to (1-p)/p, rather than 1/p.</t>

          <t>See also 'Faster than Additive Increase' (<xref
          target="pracc_faster_ai"/>)</t>
        </section>

        <section anchor="pracc_rtt_independence"
                 title="Reduced RTT Dependence">
          <t>This section addresses the 'Reduced RTT bias' aspect of Req 4.3.
          [xref-ecn-l4s-id].</t>

          <t>The DCTCP AIMD algoritm described so far is roughly inversely
          proportional to RTT (rate =~ 1/RTT) and has 2 modes of operation for
          the marking probability p, depending on whether it is controlled by
          an immediate STEP AQM (on/off mode where rate =~ 1/p^2) or by random
          marker (where rate =~ 1/p). To replace the RTT factor in the
          the equation in both modes with a specific target RTT TR = f(RTT), 
          a dynamic value which is some function of the real RTT and possibly
          other factors or in extremis even a constant, we found that both the
          window update period and the alpha
          calculation period must be aligned with TR instead of the real
          measured RTT. To achieve this, the effective rate must be multiplied
          by a factor M = TR/RTT, a number bigger than 1 if real RTT is smaller
          than the target RT. As the window W is still send within 1 real RTT, we also need
          to think in terms of a (non-existing/virtual) target window TW
          which is TR/RTT times bigger than the actual window W. This TW would
          be the window that a flow with RTT = TR would have.</t>

          <t>So to make sure the same AI in terms of rate (only 1 segment per
          TW and per TR) is applied over a shorter W and RTT flow, only 1/M
          segment fractions can be added to W per TR (as W is send M times per
          TR). An additional 1/M reduction factor needs to be applied to W
          increase per RTT, as RTT is M times shorter than TR. This explains
          why we need to increase W only by 1/M^2 fractions per RTT. In effect
          this will result in only an extra segments send per TR. The increase
          algorithm is reusing the fractional increase value as explained in
          the previous topic. Similar for longer RTTs than TR, again 1/M^2 = (RTT/TR)^2
          segments (bigger than 1 now) would need to be added per RR. The current Prague
          implementation does not support this faster AI for RTTs longer than
          TR, due to expected (though never evaluated) impact on latency
          overshoot and slowed responsiveness.</t>

          <t>The Linux TCP-Prague module supports any dynamic TR = f(RTT) to determin
          the reference RTT from the measured RTT. It currently implements 3 functions:
          f(RTT) = max(RTT, RefRTT); f(RTT) = RTT + AdditionalRTT; f(RTT) = ...
          {ToDo: enter gradual f(RTT) equation}. 
          The current default is f(RTT) = max(RTT, 25ms).</t>

          <t>To benefit from lower base RTTs the Reduced RTT Dependence
          algorithm only becomes gradual effective after a configurable amount
          D RTTs (current default 500). This means that initially the flow is
          as slow start responsive and gets an initial throughput based on its
          real RTT. Only after D RTTs the throughput will converge to the
          equal rate. The benefit is that short flows (mices) will get
          priority over longer flows, and shorter RTTs will still converge
          faster than longer RTTs.</t>
            
          <t>An idle reset time can be added {to be
          verified... or moved to section 5}.</t>
        </section>
      </section>

      <section title="Packet Pacing">
        <t>The Prague CC SHOULD pace the packets it sends to avoid the queuing
        delay and under-utilization that would otherwise be caused by bursts
        of packets that can occur, e.g. when a jump in the acknowledgement
        number opens up cwnd. Prague does this in a similar way to the base
        Linux TCP stack, by spacing out the window of packets evenly over the
        round trip time, using the following calculation of the pacing rate
        [b/s]:<list style="empty">
            <t>pacing_rate = MTU_BITS * max(cwnd, inflight) / srtt;</t>
          </list></t>

        <t>During slow start, as in the base Linux TCP stack, Prague factors
        up pacing_rate by 2, so that it paces out packets twice as fast as
        they are acknowledged. This keeps up with the doubling of cwnd, but
        still prevents bursts in response to any larger transient jumps in
        cwnd.<figure>
            <artwork><![CDATA[    if (cwnd < ssthresh / 2)
        pacing_rate *= 2;
]]></artwork>
          </figure></t>

        <t>During congestion avoidance, Prague does not factor up pacing_rate
        at all. This contrasts with the base Linux TCP stack, which factors up
        pacing_rate by a ratio parameter set to 1.2. The developers of the
        base Linux stack confirmed that this factor of 1.2 was only introduced
        in case it improved performance, but there were no scenarios where it
        was known to be needed. In testing of Prague, this factor was found to
        cause queue delay spikes whenever cwnd jumped more than usual. And
        throughput was no worse without it. So it was removed from the Prague
        CC.</t>

        <t>However, in the absence of hardware pacing, it becomes increasingly
        difficult for a machine to scale to higher flow rates unless it is
        allowed to send packets in larger bursts, for instance using
        segmentation offload. Happily, as flow rate scales up, proportionately
        more packets can be allowed in a burst for the same amount of queuing
        delay at the bottleneck.</t>

        <t>Therefore, the Prague CC sends packets in a burst as long as it
        will not induce more than MAX_BURST_DELAY of queuing at the
        bottleneck. From this constant and the current pacing_rate, it
        calculates how many MTU-sized packets to allow in a burst:<list
            style="empty">
            <t>max_burst = pacing_rate * MAX_BURST_DELAY / MTU_BITS</t>
          </list></t>

        <t>The Prague CC can use alternatives to the traditional slow-start
        algorithm, which use different pacing (see <xref
        target="pracc_flow_start"/>).</t>

        <t>It becomes increasingly difficult for a machine to scale to higher
        flow rates unless it is allowed to send packets in larger bursts, for
        instance using segmentation offload. Happily, as flow rate scales up,
        proportionately more packets can be allowed in a burst for the same
        amount of queuing delay at the bottleneck. Therefore, the Prague CC
        sends packets in a burst as long as it will not induce more than
        MAX_BURST_DELAY of queuing at the bottleneck. From this constant and
        the current pacing_rate, it calculates how many MTU-sized packets to
        allow in a burst:<list style="empty">
            <t>max_burst = pacing_rate * MAX_BURST_DELAY / MTU_BITS</t>
          </list> The current default for MAX_BURST_DELAY is 250us which
        supports marking thresholds starting from about 500us without
        underutilization.</t>
      </section>

      <section anchor="pracc_flow_start" title="Flow Start or Restart">
        <t>Currently the Prague Linux reference implementation uses the
        standard Linux slow start code. Slow start is exited ones a single
        mark is detected. When other flows are actively filling the link,
        regular marks are expected, causing slow start of new flows to end
        prematurely. See <xref target="pracc_flow_start_future"/>.</t>
      </section>
    </section>

    <section title="Variants and Future Work">
      <t/>

      <section title="Getting up to Speed Faster">
        <t/>

        <section anchor="pracc_flow_start_future"
                 title="Flow Start (or Restart)">
          <t>Pace IW (currently optional); Paced Chirping? Hystart++?</t>
        </section>

        <section anchor="pracc_faster_ai"
                 title="Faster than Additive Increase">
          <t>{ToDo:} Exploiting the invariant frequent congestion signal to
          rapidly detect when available capacity has appeared, and to start
          probing for the new operating point, e.g. using paced chirps (see
          S.3.2.3 of <xref target="PragueLinux"/>).</t>
        </section>

        <section anchor="pracc_faster_response"
                 title="Remove Lag in Congestion Response">
          <t>{ToDo: stitch this text in: As well as the inherent round trip of
          feedback delay, it introduces another round trip of delay while the
          Prague CC measures frac, before it can even start to respond to a
          change in congestion. And then the EWMA adds further rounds of
          sluggishness. Also mention invariant scale of moving average.}</t>

          <t>Removing the 1-2 rounds of unnecessary lag in DCTCP's feedback
          processing, to yield more rapidly when new flows enter the system,
          in order to enable faster convergence without the new flow having to
          push up queuing <xref target="PerAckEWMA"/>.</t>

          <t>Traditionally, TCP suppressed further response to congestion for
          a round trip because it had already triggered a large reduction
          (halving) at the first sign of congestion. DCTCP inherited the round
          trip of suppression, but not the large reduction.</t>
        </section>
      </section>

      <section anchor="pracc_delay-based"
               title="Combination of ECN-, Loss- and Delay-Based Control">
        <t>{ToDo: Give algo for cobination of Loss and ECN. Integration
        between Prague CC and BBRv2. }</t>
      </section>

      <section title="Fall-Back on Classic ECN">
        <t>This section addresses the 'Coexistence with Classic ECN' aspect of
        Req 4.3. [xref-ecn-l4s-id].</t>

        <t>{ToDo}</t>
      </section>

      <section title="Scaling Down to Fractional Windows">
        <t>This section addresses the 'Scaling to Low RTT' aspect of Req 4.3.
        [xref-ecn-l4s-id].</t>

        <t>{ToDo}</t>
      </section>
    </section>

    <section anchor="pracc_IANA" title="IANA Considerations">
      <t>This specification contains no IANA considerations.</t>
    </section>

    <section anchor="pracc_Security_Considerations"
             title="Security Considerations">
      <t>{ToDo: mention minimum window as a protection against unresponsive
      flows; and requirement to be responsive and minimize queuing delay
      [xref-l4s-arch]}</t>
    </section>

    <section title="Acknowledgements">
      <t>{ToDo} Tom Henderson, Olga Albisser, Joakim Misund.</t>

      <t>The early contributions of Koen De Schepper, Bob Briscoe and Olga
      Bondarenko were part-funded by the European Community under its Seventh
      Framework Programme through the Reducing Internet Transport Latency
      (RITE) project (ICT-317700). Bob Briscoe's contribution was also
      part-funded by the Comcast Innovation Fund and the Research Council of
      Norway through the TimeIn project. The views expressed here are solely
      those of the authors.</t>
    </section>

    <section title="Contributors">
      <t>{ToDo (this is just copied from dualq at the mo)}</t>

      <t>The following contributed implementations and evaluations that
      validated and helped to improve this specification:<list style="empty">
          <t>Olga Albisser &lt;olga@albisser.org&gt; of Simula Research Lab,
          Norway (Olga Bondarenko during early drafts) implemented the
          prototype DualPI2 AQM for Linux with Koen De Schepper and conducted
          extensive evaluations as well as implementing the live performance
          visualization GUI <xref target="L4Sdemo16"/>.</t>

          <t>Olivier Tilmans &lt;olivier.tilmans@nokia-bell-labs.com&gt; of
          Nokia Bell Labs, Belgium prepared and maintains the Linux
          implementation of DualPI2 for upstreaming.</t>

          <t>Tom Henderson &lt;tomh@tomh.org&gt; of CableLabs, US implemented
          various DualQ Coupled AQMs for ns3, including DualPI2 and DualPIE
          over point to point and DOCSIS 3.1 link models and conducted
          extensive evaluations.</t>

          <t>Ing Jyh (Inton) Tsang of Nokia, Belgium built the End-to-End Data
          Centre to the Home broadband testbed on which DualQ Coupled AQM
          implementations were tested.</t>
        </list></t>
    </section>
  </middle>

  <!--  *****BACK MATTER ***** -->

  <back>
    <references title="Normative References {ToDo}">
      <?rfc include='reference.RFC.2119'?>

      <?rfc include='reference.RFC.3168'?>

      <?rfc include='reference.RFC.8311'?>

      <?rfc include='reference.I-D.ietf-tsvwg-ecn-l4s-id'?>
    </references>

    <references title="Informative References {ToDo}">
      <?rfc include='reference.RFC.0970'?>

      <?rfc include='reference.RFC.2309'?>

      <?rfc include='reference.RFC.3246'?>

      <?rfc include='reference.RFC.3649'?>

      <?rfc include='reference.RFC.4340'?>

      <?rfc include='reference.RFC.4960'?>

      <?rfc include='reference.RFC.5033'?>

      <?rfc include='reference.RFC.5348'?>

      <?rfc include='reference.RFC.5681'?>

      <?rfc include='reference.RFC.5706'?>

      <?rfc include='reference.RFC.6679'?>

      <?rfc include='reference.RFC.7567'?>

      <?rfc include='reference.RFC.8033'?>

      <?rfc include='reference.RFC.8034'?>

      <?rfc include='reference.RFC.8257'?>

      <?rfc include='reference.RFC.8298'?>

      <?rfc include='reference.RFC.8290'?>

      <?rfc include='reference.RFC.8312'?>

      <reference anchor="ARED01" target="http://www.icir.org/floyd/red.html">
        <front>
          <title>Adaptive RED: An Algorithm for Increasing the Robustness of
          RED's Active Queue Management</title>

          <author fullname="Sally Floyd" initials="S." surname="Floyd">
            <organization>ACIRI</organization>
          </author>

          <author fullname="Ramakrishna Gummadi" initials="R."
                  surname="Gummadi">
            <organization>ACIRI</organization>
          </author>

          <author fullname="S. Shenker" initials="S." surname="Shenker">
            <organization>ACIRI</organization>
          </author>

          <date month="August" year="2001"/>
        </front>

        <seriesInfo name="ACIRI Technical Report" value=""/>

        <format target="http://www.icir.org/floyd/red.html" type="PDF"/>
      </reference>

      <?rfc include='reference.I-D.ietf-tsvwg-l4s-arch'?>

      <?rfc include='reference.I-D.ietf-tsvwg-nqb'?>

      <?rfc include='reference.I-D.briscoe-tsvwg-l4s-diffserv'?>

      <?rfc include='reference.I-D.briscoe-docsis-q-protection'?>

      <?rfc include='reference.I-D.ietf-avtcore-cc-feedback-message'?>

      <?rfc include='reference.I-D.ietf-tcpm-rack'?>

      <?rfc include='reference.I-D.ietf-tcpm-accurate-ecn'?>

      <?rfc include='reference.I-D.ietf-tcpm-generalized-ecn'?>

      <?rfc include='reference.I-D.ietf-quic-transport'?>

      <reference anchor="BBRv1"
                 target="https://tools.ietf.org/html/draft-cardwell-iccrg-bbr-congestion-control-00">
        <front>
          <title>BBR Congestion Control</title>

          <author fullname="Neal Cardwell" initials="N." surname="Cardwell">
            <organization>Google</organization>
          </author>

          <author fullname="Yuchung Cheng" initials="Y." surname="Cheng">
            <organization>Google</organization>
          </author>

          <author fullname="Soheil Hassas Yeganeh" initials="S. "
                  surname="Hassas Yeganeh">
            <organization>Google</organization>
          </author>

          <author fullname="Van Jacobson" initials="V." surname="Jacobson">
            <organization>Google</organization>
          </author>

          <date month="July" year="2017"/>
        </front>

        <seriesInfo name="Internet Draft"
                    value="draft-cardwell-iccrg-bbr-congestion-control-00"/>

        <format target="https://tools.ietf.org/html/draft-cardwell-iccrg-bbr-congestion-control-00"
                type="HTML"/>
      </reference>

      <reference anchor="Mathis09"
                 target="http://www.hpcc.jp/pfldnet2009/Program_files/1569198525.pdf">
        <front>
          <title>Relentless Congestion Control</title>

          <author fullname="Matt Mathis" initials="M." surname="Mathis">
            <organization>PSC</organization>
          </author>

          <date month="May" year="2009"/>
        </front>

        <seriesInfo name="PFLDNeT'09" value=""/>

        <format target="http://www.hpcc.jp/pfldnet2009/Program_files/1569198525.pdf"
                type="PDF"/>
      </reference>

      <!--{ToDo: DCttH ref will need to be updated, once stable}-->

      <reference anchor="DCttH15" target="http://riteproject.eu/publications/">
        <front>
          <title>`Data Centre to the Home': Ultra-Low Latency for All</title>

          <author fullname="Koen De Schepper" initials="K."
                  surname="De Schepper">
            <organization>Nokia Bell Labs</organization>
          </author>

          <author fullname="Olga Bondarenko" initials="O."
                  surname="Bondarenko">
            <organization>Simula Research Lab</organization>
          </author>

          <author fullname="Bob Briscoe" initials="B." surname="Briscoe">
            <organization>BT</organization>
          </author>

          <author fullname="Ing-jyh Tsang" initials="I." surname="Tsang">
            <organization>Nokia Bell Labs</organization>
          </author>

          <date year="2015"/>
        </front>

        <seriesInfo name="RITE project Technical Report" value=""/>

        <format target="https://riteproject.files.wordpress.com/2019/06/dctth_preprint.pdf"
                type="PDF"/>
      </reference>

      <reference anchor="PI2"
                 target="https://riteproject.files.wordpress.com/2015/10/pi2_conext.pdf">
        <front>
          <title>PI2: A Linearized AQM for both Classic and Scalable
          TCP</title>

          <author fullname="Koen De Schepper" initials="K."
                  surname="De Schepper">
            <organization>Nokia Bell Labs</organization>
          </author>

          <author fullname="Olga Bondarenko" initials="O."
                  surname="Bondarenko">
            <organization>Simula Research Lab</organization>
          </author>

          <author fullname="Bob Briscoe" initials="B." surname="Briscoe">
            <organization>BT</organization>
          </author>

          <author fullname="Ing-jyh Tsang" initials="I." surname="Tsang">
            <organization>Nokia Bell Labs</organization>
          </author>

          <date month="December" year="2016"/>
        </front>

        <seriesInfo name="ACM CoNEXT'16" value=""/>

        <format target="https://riteproject.files.wordpress.com/2015/10/pi2_conext.pdf"
                type="PDF"/>
      </reference>

      <reference anchor="L4Sdemo16"
                 target="http://dl.acm.org/citation.cfm?doid=2910017.2910633 (videos of demos: https://riteproject.eu/dctth/#1511dispatchwg )">
        <front>
          <title>Ultra-Low Delay for All: Live Experience, Live
          Analysis</title>

          <author fullname="Olga Bondarenko" initials="O."
                  surname="Bondarenko">
            <organization>Simula Research Lab</organization>
          </author>

          <author fullname="Koen De Schepper" initials="K."
                  surname="De Schepper">
            <organization>Bell Labs</organization>
          </author>

          <author fullname="Ing-jyh Tsang" initials="I." surname="Tsang">
            <organization>Bell Labs</organization>
          </author>

          <author fullname="Bob Briscoe" initials="B." surname="Briscoe">
            <organization>BT</organization>
          </author>

          <date month="May" year="2016"/>
        </front>

        <seriesInfo name="Proc. MMSYS'16" value="pp33:1--33:4"/>

        <format target="http://dl.acm.org/citation.cfm?doid=2910017.2910633"
                type="PDF"/>
      </reference>

      <!--      <reference anchor="DCTCP_Pitfalls"
                 target="http://blogs.usenix.org/conference/nsdi15/technical-sessions/presentation/judd">
        <front>
          <title>Attaining the Promise and Avoiding the Pitfalls of TCP in the
          Datacenter</title>

          <author fullname="Glenn Judd" initials="G." surname="Judd">
            <organization>Morgan Stanley</organization>
          </author>

          <date month="May" year="2015"/>
        </front>

        <seriesInfo name="12th USENIX Symposium on Networked Systems Design and Implementation (NSDI 15)"
                    value="145-157"/>

        <format target="http://blogs.usenix.org/conference/nsdi15/technical-sessions/presentation/judd"
                type="PDF"/>
      </reference>
-->

      <reference anchor="CRED_Insights"
                 target="https://arxiv.org/abs/1904.07339">
        <front>
          <title>Insights from Curvy RED (Random Early Detection)</title>

          <author fullname="Bob Briscoe" initials="B." surname="Briscoe">
            <organization>BT</organization>
          </author>

          <date day="" month="July" year="2015"/>
        </front>

        <seriesInfo name="BT Technical Report"
                    value="TR-TUB8-2015-003 arXiv:1904.07339 [cs.NI]"/>

        <format target="https://arxiv.org/pdf/1904.07339" type="PDF"/>
      </reference>

      <reference anchor="CoDel"
                 target="http://queue.acm.org/issuedetail.cfm?issue=2208917">
        <front>
          <title>Controlling Queue Delay</title>

          <author fullname="Kathleen Nichols" initials="K." surname="Nichols">
            <organization>PARC</organization>
          </author>

          <author fullname="Van Jacobson" initials="V." surname="Jacobson">
            <organization>Pollere Inc</organization>
          </author>

          <date month="May" year="2012"/>
        </front>

        <seriesInfo name="ACM Queue" value="10(5)"/>

        <format target="http://queue.acm.org/issuedetail.cfm?issue=2208917"
                type="HTML"/>
      </reference>

      <reference anchor="MEDF">
        <front>
          <title>MEDF - a simple scheduling algorithm for two real-time
          transport service classes with application in the UTRAN</title>

          <author fullname="Michael Menth " initials="M." surname="Menth">
            <organization>University of Wuerzburg</organization>
          </author>

          <author fullname="Matthias Schmid " initials="M." surname="Schmid">
            <organization>Infosim AG</organization>
          </author>

          <author fullname="Herbert Heiss" initials="H." surname="Heiss">
            <organization>Siemens</organization>
          </author>

          <author fullname="Thomas Reim" initials="T." surname="Reim">
            <organization>Siemens</organization>
          </author>

          <date month="March" year="2003"/>
        </front>

        <seriesInfo name="Proc. IEEE Conference on Computer Communications (INFOCOM'03)"
                    value="Vol.2 pp.1116-1122"/>

        <format target="http://infocom2003.ieee-infocom.org/papers/27_04.PDF"
                type="PDF"/>
      </reference>

      <reference anchor="DualQ-Test">
        <front>
          <title>Destruction Testing: Ultra-Low Delay using Dual Queue Coupled
          Active Queue Management</title>

          <author fullname="Henrik Steen" initials="H." surname="Steen">
            <organization>Uni Oslo</organization>
          </author>

          <date month="May" year="2017"/>
        </front>

        <seriesInfo name="Masters Thesis, Dept of Informatics, Uni Oslo"
                    value=""/>

        <format target="https://www.duo.uio.no/bitstream/handle/10852/57424/thesis-henrste.pdf?sequence=1"
                type="PDF"/>
      </reference>

      <reference anchor="SigQ-Dyn" target="https://arxiv.org/abs/1904.07044">
        <front>
          <title>Rapid Signalling of Queue Dynamics</title>

          <author fullname="Bob Briscoe" initials="B." surname="Briscoe">
            <organization/>
          </author>

          <date month="September" year="2017"/>
        </front>

        <seriesInfo name="Technical Report"
                    value="TR-BB-2017-001 arXiv:1904.07044 [cs.NI]"/>

        <format target="https://arxiv.org/pdf/1904.07044" type="PDF"/>
      </reference>

      <reference anchor="Alizadeh-stability"
                 target="https://dl.acm.org/citation.cfm?id=1993753">
        <front>
          <title>Analysis of DCTCP: Stability, Convergence, and
          Fairness</title>

          <author fullname="Mohamed Alizadeh" initials="M." surname="Alizadeh"/>

          <author fullname="Adel Javanmard" initials="A." surname="Javanmard"/>

          <author fullname="Balaji Prabhakar" initials="B."
                  surname="Prabhakar"/>

          <date month="June" year="2011"/>
        </front>

        <seriesInfo name="ACM SIGMETRICS 2011" value=""/>

        <format target="https://people.csail.mit.edu/alizadeh/papers/dctcp_analysis-sigmetrics11.pdf"
                type="PDF"/>
      </reference>

      <reference anchor="PragueLinux"
                 target="https://www.netdevconf.org/0x13/session.html?talk-tcp-prague-l4s">
        <front>
          <title>Implementing the `TCP Prague' Requirements for Low Latency
          Low Loss Scalable Throughput (L4S)</title>

          <author fullname="Bob Briscoe" initials="B." surname="Briscoe">
            <organization>Independent</organization>
          </author>

          <author fullname="Koen De Schepper" initials="K."
                  surname="De Schepper">
            <organization>Nokia Bell Labs</organization>
          </author>

          <author fullname="Olga Albisser" initials="O." surname="Albisser">
            <organization>Simula Research Lab</organization>
          </author>

          <author fullname="Joakim Misund" initials="J." surname="Misund">
            <organization>Simula Research Lab</organization>
          </author>

          <author fullname="Olivier Tilmans" initials="O." surname="Tilmans">
            <organization>Nokia Bell Labs</organization>
          </author>

          <author fullname="Mirja K&uuml;hlewind" initials="M."
                  surname="K&uuml;hlewind">
            <organization>ETH Zurich</organization>
          </author>

          <author fullname="Asad Sajjad Ahmed" initials="A.S." surname="Ahmed">
            <organization>Simula Research Lab</organization>
          </author>

          <date month="March" year="2019"/>
        </front>

        <seriesInfo name="Proc. Linux Netdev 0x13" value=""/>

        <format target="https://www.files.netdevconf.org/f/4d6939d5f1fb404fafd1/?dl=1"
                type="PDF"/>
      </reference>

      <reference anchor="DualPI2Linux"
                 target="https://www.netdevconf.org/0x13/session.html?talk-DUALPI2-AQM">
        <front>
          <title>DUALPI2 - Low Latency, Low Loss and Scalable (L4S)
          AQM</title>

          <author fullname="Olga Albisser" initials="O." surname="Albisser">
            <organization>Simula Research Lab</organization>
          </author>

          <author fullname="Koen De Schepper" initials="K."
                  surname="De Schepper">
            <organization>Nokia Bell Labs</organization>
          </author>

          <author fullname="Bob Briscoe" initials="B." surname="Briscoe">
            <organization>Independent</organization>
          </author>

          <author fullname="Olivier Tilmans" initials="O." surname="Tilmans">
            <organization>Nokia Bell Labs</organization>
          </author>

          <author fullname="Henrik Steen" initials="H." surname="Steen">
            <organization>Simula Research Lab</organization>
          </author>

          <date month="March" year="2019"/>
        </front>

        <seriesInfo name="Proc. Linux Netdev 0x13" value=""/>

        <format target="https://www.files.netdevconf.org/f/febbe8c6a05b4ceab641/?dl=1"
                type="PDF"/>
      </reference>

      <reference anchor="DOCSIS3.1"
                 target="https://specification-search.cablelabs.com/CM-SP-MULPIv3.1">
        <front>
          <title>MAC and Upper Layer Protocols Interface (MULPI)
          Specification, CM-SP-MULPIv3.1</title>

          <author fullname="" surname="">
            <organization>CableLabs</organization>
          </author>

          <date day="21" month="January" year="2019"/>
        </front>

        <seriesInfo name="Data-Over-Cable Service Interface Specifications DOCSIS&reg; 3.1"
                    value="Version i17 or later"/>

        <format target="https://specification-search.cablelabs.com/CM-SP-MULPIv3.1"
                type="PDF"/>
      </reference>

      <reference anchor="LLD"
                 target="https://cablela.bs/low-latency-docsis-technology-overview-february-2019">
        <front>
          <title>Low Latency DOCSIS: Technology Overview</title>

          <author fullname="Greg White" initials="G." surname="White">
            <organization>CableLabs</organization>
          </author>

          <author fullname="Karthik Sundaresan" initials="K."
                  surname="Sundaresan">
            <organization>CableLabs</organization>
          </author>

          <author fullname="Bob Briscoe" initials="B." surname="Briscoe">
            <organization>CableLabs</organization>
          </author>

          <date day="" month="February" year="2019"/>
        </front>

        <seriesInfo name="CableLabs White Paper" value=""/>

        <format target="https://cablela.bs/low-latency-docsis-technology-overview-february-2019"
                type="PDF"/>
      </reference>

      <reference anchor="AQMmetrics"
                 target="https://www.cs.purdue.edu/homes/fahmy/papers/ldc.pdf">
        <front>
          <title>A Comparison of Load-based and Queue- based Active Queue
          Management Algorithms</title>

          <author fullname="Minseok Kwon" initials="M." surname="Kwon">
            <organization>Purdue Uni</organization>
          </author>

          <author fullname="Sonia Fahmy" initials="S." surname="Fahmy">
            <organization>Purdue Uni</organization>
          </author>

          <date year="2002"/>
        </front>

        <seriesInfo name="Proc. Int'l Soc. for Optical Engineering (SPIE)"
                    value="4866:35--46 DOI: 10.1117/12.473021"/>
      </reference>

      <reference anchor="PerAckEWMA" target="https://arxiv.org/abs/2101.07727">
        <front>
          <title>Improving DCTCP/Prague Congestion Control
          Responsiveness</title>

          <author fullname="Bob Briscoe" initials="B." surname="Briscoe">
            <organization>Independent</organization>
          </author>

          <date day="20" month="January" year="2021"/>
        </front>

        <seriesInfo name="Technical Report" value="TR-BB-2020-002"/>

        <format target="https://arxiv.org/pdf/2101.07727" type="PDF"/>
      </reference>

      <reference anchor="patch-alpha-zero"
                 target="https://github.com/torvalds/linux/commits/master/net/ipv4/tcp_dctcp.c">
        <front>
          <title>tcp: allow dctcp alpha to drop to zero</title>

          <author fullname="Andrew G. Shewmaker" initials="A. G. "
                  surname="Shewmaker">
            <organization/>
          </author>

          <date day="23" month="October" year="2015"/>
        </front>

        <seriesInfo name="Linux GitHub patch;" value="Commit: c80dbe0"/>

        <format target="https://github.com/torvalds/linux/commit/c80dbe04612986fd6104b4a1be21681b113b5ac9"
                type="HTML"/>
      </reference>

      <reference anchor="patch-loss-react"
                 target="https://github.com/torvalds/linux/commits/master/net/ipv4/tcp_dctcp.c">
        <front>
          <title>tcp: Ensure DCTCP reacts to losses</title>

          <author fullname="Koen De Schepper" initials="K. "
                  surname="De Schepper">
            <organization/>
          </author>

          <date day="4" month="April" year="2019"/>
        </front>

        <seriesInfo name="Linux GitHub patch;" value="Commit: aecfde2"/>

        <format target="https://github.com/torvalds/linux/commit/aecfde23108b8e637d9f5c5e523b24fb97035dc3"
                type="HTML"/>
      </reference>

      <reference anchor="Tensions17" target="https://arxiv.org/abs/1904.07605">
        <front>
          <title>Resolving Tensions between Congestion Control Scaling
          Requirements</title>

          <author fullname="Bob Briscoe" initials="B." surname="Briscoe">
            <organization/>
          </author>

          <author fullname="Koen De Schepper" initials="K. "
                  surname="De Schepper">
            <organization/>
          </author>

          <date month="July" year="2017"/>
        </front>

        <seriesInfo name="Simula Technical Report"
                    value="TR-CS-2016-001; arXiv:1904.07605"/>

        <format target="https://arxiv.org/pdf/1904.07605" type="PDF"/>
      </reference>
    </references>

    <section title="{ToDo}">
      <t>Delete if not needed.</t>
    </section>

    <!--    <section title="Open Issues">
      <t>Minor open issues are tagged '{ToDo}' at the appropriate point in the
      document. Major open issues are listed below:<list>
          <t>None</t>
        </list></t>
    </section>

    <section title="Change Log (to be Deleted before Publication)">
      <t>A detailed version history can be accessed at
      &lt;http://datatracker.ietf.org/doc/draft-briscoe-aqm-ecn-roadmap/history/&gt;</t>

      <t><list style="hanging">
          <t hangText="From briscoe-...-00 to briscoe-...-01:">Technical
          changes:<list style="symbols">
              <t/>
            </list>Editorial changes:<list style="symbols">
              <t/>
            </list></t>
        </list></t>
    </section>
-->
  </back>
</rfc>
